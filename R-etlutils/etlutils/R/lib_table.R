# avoid check warning for data.table syntax is described here:
# https://www.r-bloggers.com/2019/08/no-visible-binding-for-global-variable/


#' Check if a table is valid.
#'
#' This function checks whether a table is valid by verifying that it is not NULL,
#' not NA, and has at least one row.
#'
#' @param table The table to be checked.
#'
#' @return TRUE if the table is valid (not NULL, not NA, and has at least one row),
#'         otherwise FALSE.
#'
#' @examples
#' # Check if a data.table is valid
#' library(data.table)
#' dt <- data.table(A = 1:3, B = c('X', 'Y', 'Z'))
#' isValid <- isValidTable(dt)
#' print(isValid)  # Output: TRUE
#'
#' @export
isValidTable <- function(table) {
  !is.null(table) && !all(is.na(table)) && nrow(table)
}

#' Add a new row to a data table.
#'
#' This function appends a new row to the end of a data table by combining the existing table with a new row
#' created from the provided values. The 'dt' parameter is the data table (data.table) to which the new row
#' will be appended, and the '...' parameter allows you to specify the values for the new row.
#'
#' @param dt A data table (data.table) to which a new row will be appended.
#' @param ... All values to fill a new row in the table.
#'
#' @return The data table with the added row. Note: all rows are converted to character type.
#'
#' @examples
#' library(data.table)
#'
#' # Create a sample data table
#' dt <- data.table(
#'   ID = 1:5,
#'   Name = c("Alice", "Bob", "Charlie", "David", "Eve"),
#'   Score = c(85, 92, 78, 65, 97)
#' )
#'
#' # Add a new row to the data table
#' dt <- addTableRow(dt, 6, 'Frank', 88)
#' print(dt)
#'
#' @export
addTableRow <- function(dt, ...) {
  vals <- list(...)
  if (length(vals) != ncol(dt)) {
    stop("Number of values does not match number of columns in data.table")
  }
  names(vals) <- names(dt)
  new_row <- data.table::as.data.table(vals)
  data.table::rbindlist(list(dt, new_row), use.names = TRUE)
}

#' Add Empty Rows to a Data Table
#'
#' This function adds a specified number of empty rows to a given data.table.
#' The empty rows have the same structure as the original data.table but contain NA values.
#'
#' @param dt A data.table to which empty rows will be added.
#' @param num_rows An integer specifying the number of empty rows to add.
#' @param position A character string specifying the position to add empty rows: either "start" or "end".
#'
#' @return A data.table with the specified number of empty rows added.
#'
#' @examples
#' library(data.table)
#' dt <- data.table(id = 1:3, value = c(10, 20, 30))
#' dt_extended_start <- addEmptyRows(dt, 2, "start")
#' print(dt_extended_start)
#' dt_extended_end <- addEmptyRows(dt, 2, "end")
#' print(dt_extended_end)
#' # same as with the parameter "end"
#' dt_extended_end <- addEmptyRows(dt, 2)
#' print(dt_extended_end)
#'
#' @export
addEmptyRows <- function(dt, num_rows, position = c("end", "start")) {
  # Match the position argument
  position <- match.arg(position)

  # Create an empty data.table with the same structure as dt
  empty_dt <- dt[0][rep(NA_integer_, num_rows)]

  # Add the empty rows to dt based on the specified position
  if (position == "start") {
    dt_extended <- rbind(empty_dt, dt)
  } else if (position == "end") {
    dt_extended <- rbind(dt, empty_dt)
  }
  return(dt_extended)
}

#' Add Custom Text Header to a Data Table
#'
#' This function adds a custom header to a given data.table. The header consists of several lines
#' and is added at the beginning of the table.
#'
#' @param dt A data.table to which the header will be added.
#' @param header A character vector containing the lines of the header.
#' @param insert_column_names_below_header A logical value indicating whether to insert column names below the header.
#'
#' @return A data.table with the custom header added at the beginning.
#'
#' @examples
#' library(data.table)
#' table <- data.table(col1 = letters[1:5], col2 = 11:15)
#' header <- c(
#'   "Hint",
#'   "This file is generated by a specific R script. Do not change it directly.",
#'   "If you want to modify it, please follow the appropriate procedure."
#' )
#' table_with_header <- addTextHeaderToTable(table, header, TRUE)
#' print(table_with_header)
#'
#' @export
addTextHeaderToTable <- function(dt, header, insert_column_names_below_header = FALSE) {
  # Calculate the number of empty rows needed
  num_empty_rows <- length(header) + 1

  if (insert_column_names_below_header) {
    num_empty_rows <- num_empty_rows + 1
  }
  # Add the empty rows at the start of the table
  dt <- etlutils::addEmptyRows(dt, num_empty_rows, "start")
  # Insert the header into the table
  dt[1:length(header), 1] <- header
  if (insert_column_names_below_header) {
    row <- as.integer(length(header) + 2)
    cols <- names(dt)
    # set single cells as character
    for (col in seq_along(dt)) {
      dt[[col]][row] <- as.character(cols[col])
    }
  }
  return(dt)
}

#'
#' Convert a list into a matrix with specified column count and fill value.
#'
#' This function takes a list and converts it into a matrix with the specified column count.
#' If the number of elements in the list is not a multiple of the column count, the 'fill' value
#' is used to pad the last row of the matrix. The resulting matrix is created with 'colCount' columns
#' and the number of rows is determined by dividing the length of the list by 'colCount'.
#'
#' @param list A list that should be converted into a matrix.
#' @param colCount The number of columns in the resulting matrix.
#' @param fill The value to fill missing values in the last row if the element count is not a
#'             multiple of the column count (default is NA).
#'
#' @return A matrix with the specified column count and optional padding in the last row.
#'
#' @examples
#' # Example 1: Convert a list into a matrix with 2 columns
#' my_list <- c(1, 2, 3, 4, 5, 6)
#' toMatrix(my_list, 2)
#'
#' # Example 2: Convert a list into a matrix with 3 columns and use 0 as the fill value
#' another_list <- c(1, 2, 3, 4, 5, 6, 7)
#' toMatrix(another_list, 3, fill = 0)
#'
#' # Example 3: Convert a list into a matrix with 4 columns and use "NA" as the fill value
#' yet_another_list <- c(1, 2, 3, 4, 5, 6, 7, 8)
#' toMatrix(yet_another_list, 4, fill = "NA")
#'
#' @export
toMatrix <- function(list, colCount, fill = NA) {
  while(length(list) %% colCount != 0) list <- c(list, fill)
  matrix(list, nrow = length(list) / colCount, byrow = TRUE)
}

#' Transform a list into a data.table with specified column names.
#'
#' This function takes a list and a corresponding list of column names (colNames)
#' to create a data.table. The 'colNames' list indicates the column count and column names
#' for the resulting table. The number of rows in the table is determined by dividing the
#' length of the input list by the column count.
#'
#' @param list The list that should be transformed into a table.
#' @param colNames A list of names that indicates the column count and column names.
#'
#' @return A data.table with the specified column count, column names, and row count
#'         determined by length(list) / column count.
#'
#' @examples
#' library(data.table)
#'
#' # Example 1: Transform a list into a data.table with 2 columns and specific column names
#' my_list <- c(1, 2, 3, 4, 5, 6)
#' col_names <- c("ColumnA", "ColumnB")
#' getTableFromList(my_list, col_names)
#'
#' # Example 2: Transform a list into a data.table with 3 columns and specific column names
#' another_list <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)
#' more_col_names <- c("First", "Second", "Third")
#' getTableFromList(another_list, more_col_names)
#'
#' @export
getTableFromList <- function(list, colNames) {
  colCount <- length(colNames)
  table <- data.table::data.table(toMatrix(list, colCount), check.names = FALSE)
  colnames(table) <- colNames
  return(table)
}

#' Read an Excel file and import each sheet as a separate data.table.
#'
#' This function reads an Excel file specified by the 'excelFile' parameter
#' and imports each sheet as a separate data.table. It returns a list of
#' imported sheets.
#'
#' @param excelFile The file path to the Excel file.
#' @param maxSheetIndex Maximum number of sheets to be read (default is 1000).
#'
#' @return A list of imported sheets as data.tables.
#'
#' @export
readExcelFileAsTableList <- function(excelFile, maxSheetIndex = 1000) {
  tables <- list()
  for (excelSheetIndex in 1:maxSheetIndex) {
    excelSheet <- try(setDT(openxlsx::read.xlsx(excelFile, excelSheetIndex, skipEmptyRows = FALSE, colNames = TRUE)), silent = TRUE)
    if (isError(excelSheet)) break
    tables <- append(tables, list(excelSheet))
  }
  sheetNames <- try(openxlsx::getSheetNames(excelFile), silent = TRUE)
  if (!isError(sheetNames)) {
    names(tables) <- sheetNames
  }
  tables
}

#' Write data to an Excel file using `openxlsx` package
#'
#' This function allows writing a data.frame or a list of objects to an Excel file.
#' The objects in the list should be compatible with `writeData()` or `writeDataTable()`
#' functions from the `openxlsx` package. It uses `write.xlsx` from `openxlsx` to perform the write operation.
#'
#' @param tables A `data.frame` or a (named) list of objects that can be handled by `writeData()`
#' or `writeDataTable()` from the `openxlsx` package to write to an Excel file.
#' @param file_name A string specifying the file path where the xlsx file will be saved.
#' @param with_column_names logical indicating whether column names should be written in the first
#' line.
#'
#' @return None
#'
#' @seealso \code{\link[openxlsx]{write.xlsx}} for the underlying function used to write Excel files.
#' @export
writeExcelFile <- function(tables, file_name, with_column_names) {
  openxlsx::write.xlsx(tables, file_name, colNames = with_column_names)
}

#' Read the first Excel file that matches the specified name pattern in the given directory.
#'
#' This function searches for Excel files in the specified directory that match the provided name pattern.
#' It reads the first matching Excel file and returns its sheets as data.tables.
#'
#' @param path The directory path where Excel files are located.
#' @param namePattern The name pattern to match Excel file names.
#' @param error_if_ambigious If more than one file is matching the name pattern and this parameter is TRUE,
#'        then an error will occur.
#'
#' @return A list of imported sheets as data.tables from the first matching Excel file,
#'         or NA if no matching file is found.
#'
#' @export
readFirstExcelFileAsTableList <- function(path, namePattern, error_if_ambigious = FALSE) {
  pattern <- paste0(".*", namePattern, ".*\\.xlsx$")
  excel_file_names <- list.files(path)
  excel_file_names <- excel_file_names[grepl(pattern, excel_file_names, perl = TRUE)]
  excel_file_names <- excel_file_names[!grepl("~", excel_file_names)]

  if (length(excel_file_names)) {
    if (length(excel_file_names) > 1 && error_if_ambigious) {
      stop(paste0("More than one excel file found. Only one is allowed in this path:\n", paste0("  ", path, "/", excel_file_names, collapse = "\n")))
    }
    excel_file_name <- file.path(path, excel_file_names[1])
    excel_file_content <- readExcelFileAsTableList(excel_file_name)
    return(list(excel_file_name = excel_file_name, excel_file_content = excel_file_content))
  }
  return(NULL)
}

#' Read the first matching Excel sheet that contains required columns
#'
#' Searches Excel files matching a pattern in a given path and returns the first sheet
#' containing the specified columns. If the columns are not present, it attempts to fix
#' the header and re-validate the sheet.
#'
#' @param path A character string indicating the directory path to search for Excel files.
#' @param namePattern A regular expression pattern to identify Excel files of interest.
#' @param columnNames A character vector of required column names that must be present in the sheet.
#'
#' @return A data.table containing the first matching and valid sheet, or NULL if no such sheet is found.
#'
#' @export
readFirstExcelFileSheet <- function(path, namePattern, columnNames) {
  excel_sheets <- readFirstExcelFileAsTableList(path, namePattern, error_if_ambigious = TRUE)
  if (is.null(excel_sheets)) {
    return(NULL)
  }
  for (i in seq_along(excel_sheets)) {
    sheet <- etlutils::removeTableHeader(excel_sheets$excel_file_content[[i]], columnNames)
    # Return first valid sheet
    if (etlutils::isValidTable(sheet)) {
      return(list(excel_file_name = excel_sheets$excel_file_name[[i]],
                  excel_file_content = sheet))
    }
  }
  return(NULL)
}

#' Replace Multiple Patterns in a Specific Column of a Data.Table
#'
#' This function replaces multiple patterns with a single replacement string
#' in a specified column of a data.table.
#'
#' @param dt A data.table containing the target column.
#' @param column_name The name of the column to perform replacements in.
#' @param patterns_to_replace A vector of patterns to search for in the column's values.
#' @param replacement The single replacement string to replace all matched patterns.
#' @param perl logical. Should Perl-compatible regexps be used?
#'
#' @return The updated data.table with specified patterns replaced by the single replacement
#'         string in the specified column.
#'
#' @examples
#' library(data.table)
#'
#' dt <- data.table(
#'   TextColumn = c("Hello,123world!", "This.is+an_example$123."),
#'   AnotherExample = c("This is a test.", "Test 123.")
#' )
#'
#' # Print the original data.table
#' print(dt)
#'
#' # Define patterns to replace as a vector
#' patterns_to_replace <- c("[0-9]", "[.,+]")
#'
#' # Define a single replacement string
#' replacement <- "*"
#'
#' # Call the function to replace patterns in the "TextColumn" column
#' dt <- replacePatternsInColumn(dt, "TextColumn", patterns_to_replace, replacement)
#'
#' # Print the updated data.table
#' print(dt)
#'
#' @export
replacePatternsInColumn <- function(dt, column_name, patterns_to_replace, replacement, perl = FALSE) {
  # Check if the specified column exists in the data.table
  if (!column_name %in% colnames(dt)) {
    return(dt)
  }

  # Loop through each pattern to replace
  for (pattern in patterns_to_replace) {
    # Binding the variable .SD locally to the function, so the R CMD check has nothing to complain about
    .SD <- NULL
    # Use gsub() to replace the pattern with the replacement in the specified column
    dt[, (column_name) := lapply(.SD, function(x) gsub(pattern, replacement, x, perl = perl)), .SDcols = column_name]
  }

  # Return the updated data.table
  return(dt)
}

#' Trim whitespace from charachter type values in a data.table or data.frame column
#'
#' This function trims leading and trailing whitespace from all character values
#' in a specified column or multiple columns of a data.table.
#'
#' @param dt A data.table or data.frame containing the target column(s).
#' @param colnames (Optional) A character vector of column names to trim.
#'                 If not specified, all columns in the data.table will be trimmed.
#'
#' @return The updated data.table or data.frame with leading and trailing whitespace trimmed
#'         from the specified column(s). In case of data.table the table will be changed by
#'         reference.
#'
#' @examples
#' library(data.table)
#'
#' df <- data.frame(
#'   col1 = c(1:4, NA),
#'   col2 = c(' A', 'B ', ' C ', ' ', NA)
#' )
#' print(dt)
#' df <- trimTableValues(df) # data.frame with assignment (pass by copy)
#' print(dt)
#'
#' # Example data.table
#' dt <- data.table(
#'   col1 = c(1:4),
#'   col2 = c(' A', 'B ', ' C ', ' ')
#' )
#' print(dt)
#' trimTableValues(dt)  # data.table without assignment (pass by reference)
#' print(dt)
#'
#' dt <- data.table(
#'   Column1 = c("  Hello  ", "  World  "),
#'   Column2 = c("  Test  ", "  Example  ")
#' )
#'
#' # Call the function to trim values in the "Column1" column
#' print(dt)
#' trimTableValues(dt, colnames = "Column1")
#' print(dt)
#'
#' @export
trimTableValues <- function(dt, colnames = NA) {
  isDataFrame <- !'data.table' %in% class(dt)
  if (isDataFrame) {
    setDT(dt) # Convert to data.table if it's a data.frame
  }

  if (is.na(colnames)) {
    colnames <- names(dt)
  }

  # Apply trimws only on character columns
  for (col in colnames) {
    if (is.character(dt[[col]]))
      dt[, (col) := trimws(get(col))]
  }

  if (isDataFrame) {
    setDF(dt) # Convert back to data.frame if the original input was a data.frame
  }

  return(dt)
}

#' Split one or multiple columns into separate rows.
#'
#' This function takes a data.table and one or more column names containing strings with
#' whitespace-separated values and splits each value into a separate row, while retaining
#' all other columns.
#'
#' @param dt The input data.table.
#' @param names_of_columns_to_split A character vector of column names to split.
#' @param split The regular expression used to split values (default is '\\s+' for whitespace).
#'
#' @return A new data.table with the specified columns split into separate rows, while retaining all other columns.
#'
#' @examples
#' library(data.table)
#' table2 <- data.table(
#'   ATC = c('A',     'B',       'C',         'D',     'E'),
#'   ICD = c('I', 'I0 H0', 'I01 H01', 'I01. H01.', 'I01.2'),
#'   SOMETHING_ELSE = 1:5
#' )
#' print(table2)
#' splitColumnsToRows(table2, c("ICD", "ATC"))
#'
#' @export
splitColumnsToRows <- function(dt, names_of_columns_to_split, split = "\\s+") {
  if (isValidTable(dt)) {
    # Save the original column order to ensure consistency in the output
    original_col_order <- names(dt)
    # Initialize the result as the input data.table
    result <- dt
    # Process each column to split
    for (col in names_of_columns_to_split) {
      if (is.character(result[[col]])) { # Ensure the column is character type
        # Split the column values based on the specified delimiter
        splitted <- strsplit(result[[col]], split)
        # Replicate rows based on the number of splits for the current column
        result <- result[rep(seq_len(nrow(result)), lengths(splitted))]
        # Replace the column with the split values
        result[[col]] <- unlist(splitted)
      }
    }
    # Restore the original column order
    data.table::setcolorder(result, original_col_order)
    return(result)
  }
  # If the table is invalid, return it unchanged
  return(dt)
}

#' Combine a List of data.tables into a single large data.table
#'
#' This function takes a list of data.tables with the same column names
#' and combines them into a single large data.table. It ensures that only
#' common columns are included in the resulting data.table.
#'
#' @param dt_list A list of data.tables to be combined.
#' @return A single data.table containing the combined data from the input list.
#' @examples
#' # Create a list of data.tables with common columns
#' library(data.table)
#' dt1 <- data.table(ID = 1:3, Value = c(10, 20, 30))
#' dt2 <- data.table(ID = 4:6, Value = c(40, 50, 60))
#' dt_list <- list(dt1, dt2)
#'
#' # Combine the data.tables into a single data.table
#' big_dt <- combineDataTables(dt_list)
#' print(dt1)
#' print(dt2)
#' print(big_dt)
#'
#' @export
combineDataTables <- function(dt_list) {
  # remove NA tables from table list
  dt_list <-  Filter(function(x) !all(is.na(x)), dt_list)
  if (length(dt_list) == 0) {
    return(NULL)
  }
  if (length(dt_list) == 1) {
    return(dt_list[[1]])
  }
  common_cols <- Reduce(intersect, lapply(dt_list, names))
  if (length(common_cols) == 0) {
    stop("No common columns found in the data.tables.")
  }
  combined_dt <- data.table::rbindlist(lapply(dt_list, function(dt) dt[, common_cols, with = FALSE]))
  return(combined_dt)
}

#' Remove rows with NA or empty values in all (!) specified columns. Emtpy means also string
#' only consisting of whitespaces.
#'
#' This function takes a data.table and a vector of column names as input and returns
#' a data.table where rows containing NA or empty values in the specified columns are removed.
#'
#' @param dt A data.table to process.
#' @param columns_to_check A character vector of column names to check for NA or empty values. If NA
#'                         then all columns will be checked.
#'
#' @return A modified data.table with rows removed based on the specified condition.
#'
#' @examples
#' # Example data.table
#' library(data.table)
#' my_data <- data.table(
#'   Column1 = c("Hello", "   World   ",   NA, "Example"),
#'   Column2 = c(      1,            NA,  " ",        NA),
#'   Column3 = c(    "A",           "B",   "",       "D")
#' )
#'
#' # Names of columns to check
#' columns_to_check <- c("Column1", "Column2", "Column3")
#'
#' # Remove rows with NA or empty values in specified columns
#' result_data <- removeRowsWithNAorEmpty(my_data, columns_to_check)
#' print(my_data)
#' print(result_data)
#'
#' # Example data.table
#' my_data <- data.table(
#'   Column1 = c("A", NA, "World", ""),
#'   Column2 = c(1, NA, 2, NA),
#'   Column3 = c("A", " ", "", NA)
#' )
#' print(my_data)
#' # Names of columns to check
#' columns_to_check <- c("Column1", "Column3")
#' # Remove rows with NA or empty values in specified columns
#' result_data <- removeRowsWithNAorEmpty(my_data)
#' print(result_data)
#'
#' @export
removeRowsWithNAorEmpty <- function(dt, columns_to_check = NA) {
  # Check if the provided data.table is empty
  if (nrow(dt) == 0) {
    return(dt)
  }
  if (isSimpleNA(columns_to_check)) {
    columns_to_check <- names(dt)
  }
  # Check the condition for each row in the data.table
  rows_to_remove <- apply(dt[, ..columns_to_check, with = FALSE], 1, function(row) {
    all(is.na(row) | (nchar(trimws(row)) == 0))
  })

  # Remove the rows that satisfy the condition
  dt <- dt[!rows_to_remove]

  return(dt)
}

#' Get the index of the first row in a data table that matches specified patterns in its columns.
#'
#' This function searches for the first row in a data table that contains matches for a set of specified patterns
#' in its columns. If the number of patterns to be matched is greater than the number of columns, it returns -1.
#'
#' @param table A data table to search for matching rows.
#' @param patterns A character vector of patterns to be matched in the columns of the table.
#' @param grep Logical, indicating whether to use `grepl` for pattern matching. Default is FALSE.
#'
#' @return The index of the first row that matches all the specified patterns, or -1 if not found.
#'
#' @examples
#' library(data.table)
#' table <- data.table(
#'   col1 = c('AAAA', 'A', 'AA', 'AAA'),
#'   col2 = c('BBBB', 'B', 'BB', 'BBB'),
#'   col3 = c('CCCC', 'C', 'CC', 'CCC'),
#'   col4 = c('DDDD', 'D', 'DD', 'DDD')
#' )
#'
#' # Find the index of the first row that contains "BBB" and "DDD" in the data table
#' index <- getFirstRowWithPatterns(table, c('BBB', 'DDD'))
#' print(index) # Output should be 4
#'
#' # Find the index of the first row that contains "BBB" or "DDD" in the data table using grepl
#' index <- getFirstRowWithPatterns(table, c('BBB', 'DDD'), TRUE)
#' print(index) # Output should be 1
#'
#' @export
getFirstRowWithPatterns <- function(table, patterns, grep = FALSE) {
  numColumns <- ncol(table)
  numPatterns <- length(patterns)

  # Check if the number of patterns is greater than the number of columns
  if (numPatterns > numColumns) {
    return(-1)
  }

  matchesPatterns <- function(row) {
    rowMatchesCount <- 0 # number of patterns
    for (colIndex in seq_len(length(row))) {
      if ((grep && grepl(patterns[rowMatchesCount + 1], row[[colIndex]])) || (!grep && patterns[rowMatchesCount + 1] %in% row[[colIndex]])) {
        rowMatchesCount <- rowMatchesCount + 1
        if (rowMatchesCount == numPatterns) {
          return(TRUE)
        }
      } else if (numColumns - colIndex < numPatterns - rowMatchesCount) { # more patterns left than columns
        break
      }
    }
    return(FALSE)
  }

  if (matchesPatterns(names(table))) {
    return(0)
  }

  for (rowIndex in seq_len(nrow(table))) {
    if (matchesPatterns(c(table[rowIndex]))) {
      return(rowIndex)
    }
  }

  return(-1)
}

#' Remove rows in a data.table up to a specified index
#'
#' This function removes all rows in a data.table up to the specified index (inclusive).
#'
#' @param dt Data table.
#' @param index Index of the row up to which rows will be removed.
#' @return The data.table with rows removed up to the specified index.
#'
#' @examples
#' # Create a sample data.table
#' library(data.table)
#' dt <- data.table(
#'   ID = 1:6,
#'   Name = c("John", "Alice", "Bob", "Eve", "Mike", "Sara"),
#'   Age = c(25, 30, 22, 28, 32, 35)
#' )
#'
#' print(dt)
#' # Remove rows up to index 3
#' dt <- removeRowsUpToIndex(dt, 3)
#' print(dt)
#'
#' @export
removeRowsUpToIndex <- function(dt, index) {
  if (index >= 1 && index <= nrow(dt)) {
    dt <- dt[-seq_len(index)]
  }
  return(dt)
}

#' Remove the table header from a data table.
#'
#' This function removes the rows above the row containing column names
#' that match the specified patterns. It then updates the column names
#' in the data table.
#'
#' @param dt A data table with a header that needs to be removed.
#' @param pattern_list A list of patterns to identify the row with column names.
#'
#' @return The data table with the header removed and updated column names.
#'
#' @examples
#' library(data.table)
#'
#' # Create a sample data table with a header
#' dt <- data.table(
#'   X1 = c("Table XYZ", "", "Name", "John", "Alice", "Bob"),
#'   X2 = c("", "", "Age", "25", "30", "22"),
#'   X3 = c("", "", "Country", "USA", "Canada", "UK")
#' )
#' print(dt)
#'
#' # Define patterns for the header row
#' header_patterns <- c("Name", "Age", "Country")
#'
#' # Remove the header and update column names
#' dt <- removeTableHeader(dt, header_patterns)
#' print(dt)
#'
#' @export
removeTableHeader <- function(dt, pattern_list) {
  colNamesRowIndex <- getFirstRowWithPatterns(dt, pattern_list)
  if (colNamesRowIndex < 0) {
    return(NA)
  }
  if (colNamesRowIndex > 0) {
    colNames <- unlist(dt[colNamesRowIndex, ])
    dt <- removeRowsUpToIndex(dt, colNamesRowIndex)
    names(dt) <- colNames
  }
  return(dt)
}

#' Retain specified columns in a data table.
#'
#' This function retains only the columns in a data table that are listed in the
#' provided 'columnNames'. All other columns will be removed from the data table.
#' Optionally, missing columns can be added with NA_character_ values.
#'
#' @param table A data table from which columns will be retained.
#' @param columnNames A character vector containing the names of columns to be retained.
#'   If NA (default), then no column will be removed and the full input table will be returned.
#' @param addMissingColumns Logical. If TRUE, columns from 'columnNames' that are not yet in
#'   the table will be created and filled with NA_character_. Default is TRUE.
#'
#' @return The data table with only the specified columns retained. The object is changed
#'   by reference.
#'
#' @examples
#' library(data.table)
#'
#' dt <- data.table(ID = 1:3, Name = c("A", "B", "C"))
#' retainColumns(dt, c("ID", "Country"), addMissingColumns = TRUE)
#'
#' dt <- data.table(ID = character(), Name = numeric())
#' retainColumns(dt, c("ID", "Country"), addMissingColumns = TRUE)
#'
#' dt <- data.table()
#' retainColumns(dt, c("ID", "Country"), addMissingColumns = TRUE)
#'
#' @export
retainColumns <- function(table, columnNames = NA, addMissingColumns = TRUE) {
  if (!isSimpleNA(columnNames)) {
    # Add missing columns as NA_character_, even for empty tables
    if (addMissingColumns) {
      missing_cols <- setdiff(columnNames, names(table))
      for (col in missing_cols) {
        table[, (col) := rep(NA_character_, .N)]
      }
    }
    # Remove all columns not in columnNames
    to_remove <- setdiff(names(table), columnNames)
    table[, (to_remove) := NULL]
  }
  return(table)
}

#' Convert list or vector columns to character in a data.table
#'
#' This function takes a data.table and converts all list-type columns into
#' character columns by concatenating the list elements with a specified separator.
#'
#' @param dt The input data.table.
#' @param separator The separator to use when concatenating list elements (default is " ~ ").
#'
#' @return Returns the modified data.table with list columns converted to character columns.
#'
#' @examples
#' library(data.table)
#'
#' # Create example data
#' dt <- data.table(
#'   ID = 1:3,
#'   Names = list(c("Alice", "Bob"), c("Charlie", "David"), c("Eve", "Frank")),
#'   Scores = list(c(85, 92), c(78, 89), c(95, 88))
#' )
#' print(dt)
#'
#' # Convert list columns to character columns
#' dt <- convertListColumnsToString(dt)
#' print(dt)
#'
#' @export
convertListColumnsToString <- function(dt, separator = " ~ ") {
  # Loop through all columns in the data.table
  for (col_name in names(dt)) {
    # Check if the column has a "list" type
    if (is.list(dt[[col_name]])) {
      # Loop through the list elements and concatenate them
      for (i in seq_len(nrow(dt))) {
        if (!is.null(dt[[col_name]][[i]]) && !all(is.na(dt[[col_name]][[i]]))) {
          newValue <- as.character(paste(dt[[col_name]][[i]], collapse = separator))
          dt[i, (col_name) := newValue]
        }
      }
      # change column class to character
      dt[, (col_name) := as.character(get(col_name))]
    }
  }
  return(dt)
}

#' Get the index of a column in a data.table by its name.
#'
#' This function returns the index of the first column in a data.table that matches
#' the specified column name.
#'
#' @param table A data.table.
#' @param columnName The name of the column to search for.
#'
#' @return The index of the specified column, or 0 if the column is not found.
#'
#' @examples
#' library(data.table)
#'
#' # Create a sample data.table
#' dt <- data.table(ID = 1:5, Name = c("Alice", "Bob", "Charlie", "David", "Eve"))
#'
#' # Get the index of the "Name" column
#' index <- getcolumnIndex(dt, "Name")
#' print(index)  # Output: [1] 2
#'
#' # Try to get the index of a non-existing column
#' index <- getcolumnIndex(dt, "Age")
#' print(index)  # Output: [1] 0
#'
#' # Try to get the index of column name NA
#' index <- getcolumnIndex(dt, NA)
#' print(index)  # Output: [1] 0
#'
#' @export
getcolumnIndex <- function(table, columnName) {
  if (is.data.table(table) && is.character(columnName) && length(columnName) == 1) {
    names <- names(table)
    for (i in seq_len(length(names))) {
      if (names[i] %in% columnName) {
        return(i)
      }
    }
  }
  return(0)
}

#' Move a column in a data.table directly before another column based on indices
#'
#' This function takes a data.table, the name of the column to be moved, and
#' the name of the target column before which the first column should be placed.
#' It adjusts the order of the columns in the data.table accordingly by manipulating
#' column indices, without altering other columns' order unnecessarily.
#'
#' @param dt A data.table object.
#' @param column_to_move The name of the column to move.
#' @param target_column The name of the column before which to place the moved column.
#'
#' @return The data.table with adjusted column order. The original data.table is modified by reference.
#'
#' @examples
#' library(data.table)
#' dt <- data.table(x = 1:3, y = 4:6, z = 7:9)
#' moveColumnBefore(dt, "y", "z")
#' print(dt) # Should show columns in the order x, z, y
#'
#' @export
moveColumnBefore <- function(dt, column_to_move, target_column) {
  # Find the current positions of the columns
  cols <- names(dt)
  move_index <- which(cols == column_to_move)
  target_index <- which(cols == target_column)

  new_order <- c(cols[-c(move_index)], cols[move_index])
  # Adjust if move_index is before target_index, considering direct placement before target
  if (move_index >= target_index) {
    # Correct the order for when the column is moved forward
    target_index <- target_index + (target_index > move_index)
    new_order <- c(new_order[1:(target_index - 1)], new_order[length(new_order)], new_order[target_index:(length(new_order) - 1)])
  }

  # Apply the new order
  data.table::setcolorder(dt, new_order)
}

#' Append rows to a data.table with values in the first column
#'
#' Adds one row per element in `values` to the provided data.table. If a value is `NA` or an empty
#' string, a fully empty row is added. Otherwise, the value is inserted into the first column
#' of the new row. The function returns the modified table and does not modify by reference.
#'
#' @param table A data.table to which rows will be appended. Must have at least one column,
#'   and the first column is expected to be of type character.
#' @param values A character vector of values to insert into the first column. NA or "" will
#'   result in a completely empty row.
#'
#' @return A data.table with the new rows appended.
#'
#' @examples
#' dt <- data.table::data.table(col1 = character(), col2 = integer())
#' values <- c("First", NA, "", "Second")
#' dt <- addRowsWithFirstColumn(dt, values)
#'
#' @export
addRowsWithFirstColumn <- function(table, values) {
  for (val in values) {
    row <- setNames(as.list(rep(NA, ncol(table))), names(table))
    if (!is.na(val) && val != "") {
      row[[1]] <- val
    }
    table <- data.table::rbindlist(list(table, row), use.names = TRUE, fill = TRUE)
  }
  return(table)
}

#' Print a summary for a table
#'
#' This function prints a summary for the specified table, including information
#' about the class, type, number of available values, and number of missing values
#' for each column. The summary is displayed in a formatted table.
#'
#' @param table The input table to summarize. For example, you can use the mtcars dataset.
#' @param table_name An optional name for the table, used in the summary output.
#' @return This function does not explicitly return a value. It prints the summary to the console.
#'
#' @examples
#' # Load required packages
#' library(datasets)
#' library(data.table)
#'
#' # Load the mtcars dataset and convert it to a data.table
#' data(mtcars)
#' setDT(mtcars)
#'
#' # Print summary for the mtcars table
#' printTableSummary(table = mtcars, table_name = 'mtcars')
#'
#' @export
printTableSummary <- function(table, table_name = '') {
  dt <- data.table::as.data.table(
    cbind(
      class      = sapply(names(table), function(n) class(table[[n]])[1]), #shows only the first specified class
      type       = sapply(names(table), function(n) typeof(table[[n]])),
      available  = sapply(names(table), function(n) sum(!is.na(table[[n]]))),
      missing    = sapply(names(table), function(n) sum( is.na(table[[n]])))
    ),
    keep.rownames = TRUE
  )
  if (0 < nrow(dt)) {
    cat(
      createFrameString(
        text = paste0(
          'Table: ', table_name, '\n\n  # Rows:    ', nrow(table), '\n  # Columns: ', ncol(table), '\n\n',
          dataTableAsCharacter(
            data.table::setnames(
              x = dt,
              new = c('Column', 'Class', 'Type', 'Available', 'Missing')
            ),
            header = TRUE,
            footer = TRUE
          )
        ),
        edge = c('\u231c\u231d\u231e\u231f'),
        hori = ' ',
        vert = ' '
      )
    )
  } else {
    cat(
      createFrameString(
        text = paste0(
          'Table: ', table_name, '\n\n  # Rows:    ', nrow(table), '\n  # Columns: ', ncol(table), '\n\n'
        ),
        edge = c('\u231c\u231d\u231e\u231f'),
        hori = ' ',
        vert = ' '
      )
    )
  }
}

#' Convert Data.Table to Character String
#'
#' This function converts a data.table to a formatted character string with optional header and footer.
#'
#' @param dt A data.table to be converted.
#' @param header Logical, indicating whether to include a header with column names.
#' @param footer Logical, indicating whether to include a footer with column names.
#' @return A formatted character string representation of the data.table.
#'
#' @details
#' The function converts a data.table to a character string, aligning columns and optionally including a header and footer.
#' It pads each column to the maximum width of its elements for better alignment.
#'
#' @export
dataTableAsCharacter <- function(dt, header = FALSE, footer = FALSE) {
  if (nrow(dt) == 0 && !header && !footer) {
    return("")
  }

  .SD <- NULL
  d <- if (header) rbind(as.list(names(dt)), dt) else dt
  if (footer) d <- rbind(d, as.list(names(dt)))
  if (nrow(d) == 0) {
    return(paste(names(dt), collapse = '  '))
  }
  l <- d[, lapply(.SD, function(x) max(nchar(as.character(x))))]
  d <- data.table::as.data.table(lapply(seq_along(d), function(i) stringr::str_pad(string = as.character(d[[i]]), width = l[[i]], side = 'left', pad = ' ')))
  paste0(
    sapply(
      seq_len(nrow(d)),
      function(i) {
        paste0(d[i, ], collapse = '  ')
      }
    ),
    collapse = '\n'
  )
}

#' Fill NA Values with Last Observed Value in Specified Columns of a data.table
#'
#' This function fills NA values in a data.table by carrying forward the last observed value.
#' If an NA value is found, it is replaced by the most recent non-NA value in the column.
#' If the first value in a column is NA, it remains NA.
#'
#' @param dt A data.table object in which NA values need to be filled.
#' @param columns A vector of column names to be processed. If NA (default), all columns are processed.
#' @return A data.table with NA values filled.
#' @examples
#' library(data.table)
#' dt <- data.table(A = c(0, 1, NA, NA, 4, 5), B = c(NA, "x", NA, "z", NA, NA))
#' fillNAWithLastRowValue(dt)
#' fillNAWithLastRowValue(dt, columns = "B")
#' dt <- data.table(A = c(1), B = c("x"))
#' fillNAWithLastRowValue(dt)
#' fillNAWithLastRowValue(dt, columns = "B")
#' dt <- data.table(A = c(NA, 1), B = c(NA, "x"))
#' fillNAWithLastRowValue(dt)
#' fillNAWithLastRowValue(dt, columns = "B")
#' @export
fillNAWithLastRowValue <- function(dt, columns = NA) {
  # if columns parameter is NA -> take all columns
  if (is.na(columns)) {
    columns <- names(dt)
  }

  if (nrow(dt) > 1) {
    # fill NA values
    dt[, (columns) := lapply(.SD, function(x) {
      for (i in 2:length(x)) {
        if (is.na(x[i])) {
          x[i] <- x[i - 1]
        }
      }
      return(x)
    }), .SDcols = columns]
  }

  return(dt)
}

#' Split a data.table into a List by a Specified Column
#'
#' This function splits a data.table into a list of data.tables based on the unique values in a
#' specified column. Each list element contains the rows where the value in the specified column
#' is the same.
#'
#' @param dt A data.table to be split.
#' @param split_columnname A character string specifying the column name by which to split the
#' data.table.
#' @param fill_na_in_split_columnname A logical value indicating whether to fill NA values in the
#' specified column with the last non-NA value. Default is FALSE.
#' @param rm.na A logical value indicating whether to remove list elements where the split column
#' value is NA. Default is FALSE.
#'
#' @return A list of data.tables, with each element containing the rows with the same value in the
#' specified column. The names of the list elements are set to the unique values of the specified
#' column.
#'
#' @examples
#' library(data.table)
#' dt <- data.table(
#'   SCRIPTNAME = c("A", "A", "B", "B", NA, "", "C"),
#'   VALUE = 1:7
#' )
#' result <- splitTableToList(dt, "SCRIPTNAME")
#' print(result)
#'
#' # Remove NA elements
#' result_no_na <- splitTableToList(dt, "SCRIPTNAME", rm.na = TRUE)
#' print(result_no_na)
#'
#' @export
splitTableToList <- function(dt, split_columnname, fill_na_in_split_columnname = FALSE, rm.na = FALSE) {
  dt <- data.table::copy(dt) # prevent changing the original table

  # Convert empty strings to NA only if the split column is character
  if (is.character(dt[[split_columnname]])) {
    dt[get(split_columnname) == "", (split_columnname) := NA_character_]
  }

  # Optionally fill NA in the split column using last non-NA value
  if (fill_na_in_split_columnname) {
    fillNAWithLastRowValue(dt, split_columnname)
  }

  # Split into list by the split column
  splitted <- split(dt, by = split_columnname, keep.by = TRUE)

  # Optionally remove the NA group robustly (do not rely on list names)
  if (rm.na) {
    splitted <- Filter(function(x) !isTRUE(all(is.na(x[[split_columnname]]))), splitted)
  }

  return(splitted)
}

#' Collapse Rows of a data.table by Groups
#'
#' This function collapses the rows of a data.table into a single row per group. Different values in the
#' rows are converted into a string with the values separated by a specified delimiter. NA values are
#' excluded from the concatenated string and will only appear as NA if all values in the column are NA.
#'
#' @param dt A data.table to be collapsed.
#' @param group_col The column name by which to group the data.table. Default is NA, meaning no grouping.
#' @param delimiter A string used to separate the different values. Default is "; ".
#'
#' @return A data.table with one row per group, where each column contains a string of concatenated values
#' or NA if all values were NA.
#'
#' @examples
#' library(data.table)
#' patient <- data.table(
#'   id = c(1, 2, 3, 3),
#'   group = c("A", "A", "B", "B"),
#'   name = c("Alice", "Bob", "Charlie", "Alice"),
#'   pat_identifier_system = c("[1.1]abcdefg", "[1.2.3]hijklmn", "[2.3.4.5]opqrstu", NA),
#'   status = c(NA, NA, "ok", "error")
#' )
#' collapseRowsByGroup(patient, "group")
#' collapseRowsByGroup(patient)
#'
#' @export
collapseRowsByGroup <- function(dt, group_col = NA, delimiter = "; ") {
  # Function to collapse values in a column
  collapse_column <- function(x) {
    non_na_values <- unique(na.omit(x))
    if (length(non_na_values) > 0) {
      collapsed_values <- paste(non_na_values, collapse = delimiter)
      return(collapsed_values)
    } else {
      return(NA_character_)
    }
  }

  # Check if group_col is provided or not
  if (is.na(group_col)) {
    # Collapse all rows without grouping
    if (nrow(dt) > 1) {
      collapsed_dt <- dt[, lapply(.SD, collapse_column)]
    } else {
      collapsed_dt <- dt
    }
  } else {
    # Group by the specified column and collapse the values in each group
    collapsed_dt <- dt[, lapply(.SD, collapse_column), by = group_col]
  }

  return(collapsed_dt)
}

#' Replace values in a column of a data.table
#'
#' This function replaces all values in a specified column of a data.table that match
#' a given old value with a new value. Either the old or new value can be NA.
#'
#' @param dt A data.table object.
#' @param column_name A string representing the name of the column to modify.
#' @param old_type The value to be replaced. Can be a string or NA.
#' @param new_type The value to replace with. Can be a string or NA.
#'
#' @examples
#' dt <- data.table::data.table(a = c("x", "y", "x", NA, "y"))
#' replaceColumnValues(dt, "a", "x", "z")
#' # dt now has column "a" with values "z", "y", "z", NA, "y"
#' replaceColumnValues(dt, "a", NA, "unknown")
#' # dt now has column "a" with values "z", "y", "z", "unknown", "y"
#'
#' @export
replaceColumnValues <- function(dt, column_name, old_type, new_type) {
  if (is.na(old_type)) {
    dt[is.na(get(column_name)), (column_name) := new_type]
  } else {
    dt[get(column_name) == old_type, (column_name) := new_type]
  }
}

#' Merge Two Lists of Tables by Combining Rows with Shared Table Names
#'
#' This function merges two lists of data tables, uniting table names from both lists.
#' If a table is present in both lists, it combines rows while retaining only columns common to both tables.
#' Tables that exist in only one list are directly added to the final output without modification.
#'
#' @param list1 A named list of data.table objects representing the first set of tables for merging.
#' @param list2 A named list of data.table objects representing the second set of tables for merging.
#'
#' @details The function iterates over each unique table name in both input lists.
#' If a table appears in both lists, it keeps only the common columns, combines rows using `rbind`,
#' and adds the merged table to the final output. If a table is present in only one list, it is
#' included in the final list as-is.
#'
#' @return A list containing the merged tables. Each table has only columns common to both lists,
#' if applicable. Tables that appear in only one list are included in the final output without alteration.
#'
#' @examples
#' library(data.table)
#' # Define two example lists with overlapping table names and distinct columns
#' list1 <- list(tableA = data.table(x = 1:3, y = 4:6, z = 7:9),
#'               tableB = data.table(x = 7:9, z = 10:12))
#' list2 <- list(tableA = data.table(x = 10:12, y = 13:15),
#'               tableC = data.table(w = 1:3))
#' # Merge tables from both lists
#' merged_tables <- mergeTablesUnion(list1, list2)
#'
#' @export
mergeTablesUnion <- function(list1, list2) {
  # Initialize the combined list to store the merged tables
  combined_list <- list()
  # Create a set of all unique table names across both lists
  all_table_names <- union(names(list1), names(list2))
  # Iterate over each table name in the combined set
  for (table_name in all_table_names) {
    # Case 1: Table exists in both lists
    if (table_name %in% names(list1) && table_name %in% names(list2)) {
      # Extract the corresponding tables from each list
      table1 <- list1[[table_name]]
      table2 <- list2[[table_name]]
      # Combine the tables using rbind
      combined_table <- rbind(table1, table2, fill = TRUE)
    } else if (table_name %in% names(list1)) {
      # Case 2: Table exists only in list1
      combined_table <- list1[[table_name]]
    } else {
      # Case 3: Table exists only in list2
      combined_table <- list2[[table_name]]
    }
    # Add the combined (or single) table to the result list
    combined_list[[table_name]] <- combined_table
  }
  return(combined_list)
}

#' Filter rows of a data.table by regex pattern on a specific column
#'
#' This function filters the given data.table by applying a regular expression pattern to a specified
#' column. If the pattern is empty or matches any string (e.g., ".*"), the original table is returned
#' unmodified. If no rows match the pattern, an error message is printed using
#' \code{etlutils::catErrorMessage()} and \code{NA} is returned.
#'
#' @param dt A \code{data.table} to filter.
#' @param column_name The name of the column (as string) to apply the pattern to.
#' @param pattern A regular expression used to match against the specified column.
#'
#' @return A filtered \code{data.table} if matching rows exist, otherwise \code{NA}. If the pattern is
#'         empty or matches any string, the original table is returned.
#'
#' @examples
#' dt <- data.table::data.table(name = c("Alice", "Bob", "Charlie"))
#' dtFilterRows(dt, "name", "^A")  # Returns only row with Alice
#' dtFilterRows(dt, "name", ".*")  # Returns original table
#' dtFilterRows(dt, "name", "^Z")  # Returns NA and prints error
#'
#' @export
dtFilterRows <- function(dt, column_name, pattern) {
  # If the pattern is empty (same as any string) or matches any string, return the original table
  if (pattern %in% c("", ".*")) {
    return(dt)
  }
  # remove rows where colum value does not match the pattern
  dt_filtered <- dt[grepl(pattern, get(column_name))]
  # check error no row left after filtering
  if (!nrow(dt_filtered)) { #
    dt_printed <- capture.output(print(dt))
    etlutils::catErrorMessage(paste0("No rows found with a '", column_name, "' matching pattern '", pattern, "' in table\n",  paste0(dt_printed, collapse = "\n")))
    return(NA)
  }
  return(dt_filtered)
}

#' Remove comment and empty rows from a data.table
#'
#' Removes all rows from a data.table where the first non-empty, non-NA entry in a row (after
#' trimming whitespace) starts with a specified comment marker. By default, rows that are entirely
#' empty (i.e. contain only \code{NA}, empty strings, or whitespace) are also removed. This behavior
#' can be disabled.
#'
#' @param dt A \code{data.table} to clean. All columns are scanned row-wise, left to right.
#' @param comment_marker A character string that indicates a comment. Defaults to \code{"#"}.
#' @param remove_empty Logical flag indicating whether to remove rows with no meaningful content.
#'   Defaults to \code{TRUE}.
#'
#' @return A \code{data.table} with comment rows (and optionally empty rows) removed. Original row
#'   order is preserved.
#'
#' @examples
#' input <- data.table::data.table(
#'   V1 = c("# comment", NA, "value", "   ", "@note", "", NA),
#'   V2 = c(NA, "#ignore", "keep", " ", "entry", " ", NA)
#' )
#' dtRemoveCommentRows(input) # removes comments and empty rows
#' dtRemoveCommentRows(input, comment_marker = "@") # removes "@" comments and empty rows
#' dtRemoveCommentRows(input, remove_empty = FALSE) # only removes comments
#'
#' @export
dtRemoveCommentRows <- function(dt, comment_marker = "#", remove_empty = TRUE) {
  rows_to_remove <- dt[
    , {
      row_values <- trimws(as.character(unlist(.SD)))
      row_values <- row_values[!is.na(row_values) & row_values != ""]
      should_remove <- FALSE

      if (length(row_values) == 0) {
        should_remove <- remove_empty
      } else {
        should_remove <- startsWith(row_values[1], comment_marker)
      }

      list(remove = should_remove)
    },
    by = seq_len(nrow(dt))
  ][remove == TRUE, seq_len]

  if (length(rows_to_remove) > 0) {
    dt <- dt[-rows_to_remove]
  }

  return(dt)
}

#' Rename columns in a list of data.tables
#'
#' Renames one or more columns in each data.table contained in a list.
#' Column renaming is performed by reference using \code{data.table::setnames()},
#' so the original data.tables are modified in place.
#'
#' Columns that are not present in a specific table are silently skipped.
#'
#' @param tbl_list A list of \code{data.table} objects.
#' @param old A character vector of existing column names to be renamed.
#' @param new A character vector of new column names. Must be the same length as \code{old}.
#'
#' @return A list of \code{data.table}s with renamed columns (same objects, modified by reference).
#'
#' @export
renameColsInLists <- function(tbl_list, old, new) {
  lapply(tbl_list, function(tbl) {
    data.table::setnames(tbl, old = old, new = new, skip_absent = TRUE)
    tbl
  })
}

