################
# isValidTable #
################

test_that('Test isValidTable()', {
  expect_false(isValidTable(NA))
  expect_false(isValidTable(NULL))
  expect_false(isValidTable(data.table()))
  expect_false(isValidTable(data.table(col1 = c(NA, NA))))
  expect_true(isValidTable(data.table(col1 = 'AAA')))
})

###############
# addTableRow #
###############

test_that('Test addTableRow', {
  # Create a sample data table
  dt <- data.table(
    ID = 1:5,
    Name = c("Alice", "Bob", "Charlie", "David", "Eve"),
    Score = c(85, 92, 78, 65, 97)
  )
  expect_equal(nrow(dt), 5)

  # Add a new row to the data table
  # addTableRow converts all columns to character
  dt <- addTableRow(dt, 6, 'Frank', 88)

  expect_equal(nrow(dt), 6)
  expect_equal(dt[6][[1]], '6')
  expect_equal(dt[6][[2]], 'Frank')
  expect_equal(dt[6][[3]], '88')
})

################
# addEmptyRows #
################

test_that("addEmptyRows adds rows at the start", {
  dt <- data.table(id = 1:3, value = c(10, 20, 30))
  dt_extended <- addEmptyRows(dt, 2, "start")

  expect_equal(nrow(dt_extended), nrow(dt) + 2)
  expect_true(all(is.na(dt_extended[1:2, ]$id)))
  expect_true(all(is.na(dt_extended[1:2, ]$value)))
  expect_equal(dt_extended[3:5, ], dt)
})

test_that("addEmptyRows adds rows at the end", {
  dt <- data.table(id = 1:3, value = c(10, 20, 30))
  dt_extended <- addEmptyRows(dt, 2, "end")

  expect_equal(nrow(dt_extended), nrow(dt) + 2)
  expect_equal(dt_extended[1:3, ], dt)
  expect_true(all(is.na(dt_extended[4:5, ]$id)))
  expect_true(all(is.na(dt_extended[4:5, ]$value)))
})

test_that("addEmptyRows works with zero rows", {
  dt <- data.table(id = 1:3, value = c(10, 20, 30))
  dt_extended_start <- addEmptyRows(dt, 0, "start")
  dt_extended_end <- addEmptyRows(dt, 0, "end")

  expect_equal(dt_extended_start, dt)
  expect_equal(dt_extended_end, dt)
})

test_that("addEmptyRows handles invalid position argument", {
  dt <- data.table(id = 1:3, value = c(10, 20, 30))
  expect_error(addEmptyRows(dt, 2, "middle"))
})

test_that("addEmptyRows handles negative number of rows", {
  dt <- data.table(id = 1:3, value = c(10, 20, 30))
  expect_error(addEmptyRows(dt, -1, "start"))
})

test_that("addEmptyRows retains column names and types", {
  dt <- data.table(id = 1:3, value = c(10, 20, 30))
  dt_extended <- addEmptyRows(dt, 2, "end")

  expect_equal(colnames(dt_extended), colnames(dt))
  expect_equal(sapply(dt_extended, class), sapply(dt, class))
})

########################
# addTextHeaderToTable #
########################

test_that("addTextHeaderToTable adds header correctly", {
  dt <- data.table(col1 = letters[1:5], col2 = 11:15)
  header <- c(
    "Hint",
    "This file is generated by a specific R script. Do not change it directly.",
    "If you want to modify it, please follow the appropriate procedure."
  )

  dt_with_header <- addTextHeaderToTable(dt, header, FALSE)

  expect_equal(nrow(dt_with_header), nrow(dt) + length(header) + 1)
  expect_equal(dt_with_header[1:length(header), col1], header)
  expect_true(all(is.na(dt_with_header[length(header) + 1, ]$col1)))
})

test_that("addTextHeaderToTable inserts column names correctly", {
  dt <- data.table(col1 = letters[1:5], col2 = 11:15)
  header <- c(
    "Hint",
    "This file is generated by a specific R script. Do not change it directly.",
    "If you want to modify it, please follow the appropriate procedure."
  )

  dt_with_header <- addTextHeaderToTable(dt, header, TRUE)

  expect_equal(nrow(dt_with_header), nrow(dt) + length(header) + 2)
  expect_equal(dt_with_header[1:length(header), col1], header)
  expected_col_names <- as.list(names(dt))
  names(expected_col_names) <- names(dt)
  expect_equal(as.list(dt_with_header[length(header) + 2, ]), expected_col_names)
  expect_true(all(is.na(dt_with_header[length(header) + 1, ]$col1)))
})

test_that("addTextHeaderToTable handles NULL header", {
  dt <- data.table(col1 = letters[1:5], col2 = 11:15)

  expect_error(addTextHeaderToTable(dt, NULL, FALSE))
})

test_that("addTextHeaderToTable retains column names and types", {
  dt <- data.table(col1 = letters[1:5], col2 = 11:15)
  header <- c("Hint")

  dt_with_header <- addTextHeaderToTable(dt, header, FALSE)

  expect_equal(colnames(dt_with_header), colnames(dt))
  expect_equal(sapply(dt_with_header, class), sapply(dt, class))
})

############
# toMatrix #
############

# Test 1: Checks whether the conversion to a matrix with 2 columns works correctly
test_that("toMatrix converts a list into a matrix with specified column count correctly", {
  my_list <- c(1, 2, 3, 4, 5, 6)
  result_matrix <- toMatrix(my_list, 2)
  expect_equal(dim(result_matrix), c(3, 2))
  expect_equal(result_matrix[3, 2], 6)
})

# Test 2: Checks whether the fill value is used correctly if the number of elements is not a multiple of the number of columns
test_that("toMatrix uses fill value correctly when list length is not a multiple of column count", {
  another_list <- c(1, 2, 3, 4, 5, 6, 7)
  result_matrix <- toMatrix(another_list, 3, fill = 0)
  expect_equal(dim(result_matrix), c(3, 3))
  expect_equal(result_matrix[3, 3], 0)
})

# Test 3: Checks whether the default fill value is used correctly
test_that("toMatrix uses default fill value correctly", {
  yet_another_list <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)
  result_matrix <- toMatrix(yet_another_list, 4)
  expect_equal(dim(result_matrix), c(3, 4))
  expect_true(is.na(result_matrix[3, 4]))
})

####################
# getTableFromList #
####################

# Assuming toMatrix is already correctly implemented and tested
# Test for getTableFromList function
test_that("getTableFromList transforms a list into a data.table with specified column names correctly", {
  # Test 1: Simple transformation with 2 columns
  my_list <- c(1, 2, 3, 4, 5, 6)
  col_names <- c("ColumnA", "ColumnB")
  result_table <- getTableFromList(my_list, col_names)

  # Verify the structure and content
  expect_true(is.data.table(result_table))
  expect_equal(colnames(result_table), col_names)
  expect_equal(nrow(result_table), length(my_list) / length(col_names))
  expect_equal(ncol(result_table), length(col_names))

  # Test 2: Transformation with 3 columns
  another_list <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)
  more_col_names <- c("First", "Second", "Third")
  result_table_2 <- getTableFromList(another_list, more_col_names)

  # Verify the structure and content for the second test
  expect_true(is.data.table(result_table_2))
  expect_equal(colnames(result_table_2), more_col_names)
  expect_equal(nrow(result_table_2), length(another_list) / length(more_col_names))
  expect_equal(ncol(result_table_2), length(more_col_names))
})

############################
# readExcelFileAsTableList #
############################

# integration test for readExcelFileAsTableList
test_that("readExcelFileAsTableList imports Excel sheets correctly", {
  # Setup: Use a predefined Excel file for testing
  test_file_path <- system.file("extdata", "test_excel_file.xlsx", package = "etlutils")

  # Action: Read the Excel file
  result <- try(readExcelFileAsTableList(test_file_path))

  # Verify: Check if the result is as expected
  expect_true(is.list(result), info = "The result should be a list.")
  expect_equal(length(result), 2, info = "The result list should contain two data.tables for the two sheets.")
  expect_equal(names(result), c('mtcars_with_description_lines', 'mtcars_without_description_line'))

  # reading non existing files returns an empty list
  result <- readExcelFileAsTableList('not_existing_file_path')
  expect_true(length(result) == 0 && is.list(result))
})

##################
# writeExcelFile #
##################

test_that("writeExcelFile writes a data.table to an Excel file", {
  temp_file <- tempfile(fileext = ".xlsx")
  on.exit(unlink(temp_file))

  dt <- data.table(a = 1:3, b = letters[1:3])

  writeExcelFile(dt, temp_file, TRUE)

  dt_read <- openxlsx::read.xlsx(temp_file)
  expect_equal(dt, data.table::as.data.table(dt_read))
})

# test_that("writeExcelFile writes data without column names when specified", {
#   temp_file <- tempfile(fileext = ".xlsx")
#   on.exit(unlink(temp_file))
#
#   dt <- data.table(a = 1:3, b = letters[1:3])
#
#   writeExcelFile(dt, temp_file, FALSE)
#
#   dt_read <- data.table::fread(temp_file, header = FALSE)
#   expect_equal(dt, setnames(as.data.table(dt_read), names(dt)))
# })
#
# test_that("writeExcelFile handles an empty data.table", {
#   temp_file <- tempfile(fileext = ".xlsx")
#   on.exit(unlink(temp_file))
#
#   dt <- data.table(a = numeric(0), b = character(0))
#
#   writeExcelFile(dt, temp_file, TRUE)
#
#   dt_read <- data.table::as.data.table(openxlsx::read.xlsx(temp_file))
#   expect_equal(dt, dt_read)
# })

#################################
# readFirstExcelFileAsTableList #
#################################

# Test for readFirstExcelFileAsTableList function
test_that("readFirstExcelFileAsTableList reads the first matching Excel file correctly", {
  # Define the path to the test directory (assuming the working directory is the package root)
  test_path <- system.file("extdata", package = "etlutils")

  # Define the name pattern to search for
  name_pattern <- "test_excel_file"

  # Execute the function
  result <- readFirstExcelFileAsTableList(test_path, name_pattern)

  # Verify the result
  expect_true(is.list(result), info = "The result should be a list.")
  expect_equal(length(result), 2, info = "The result list should contain two data.tables for the two sheets.")

  # Further checks can be added to verify the content of the data.tables if needed
  # For example, checking the number of rows and columns of each data.table in the list
})

###########################
# replacePatternsInColumn #
###########################

# Test for basic functionality
test_that("replacePatternsInColumn replaces patterns correctly", {
  dt <- data.table(TextColumn = c("Hello,123world!", "This.is+an_example$123."))
  patterns_to_replace <- c("[0-9]", "[.,+_!]")
  replacement <- "*"

  expected <- data.table(TextColumn = c("Hello****world*", "This*is*an*example$****"))

  result <- replacePatternsInColumn(dt, "TextColumn", patterns_to_replace, replacement)

  expect_equal(result, expected)
})

# Test for column existence
test_that("replacePatternsInColumn handles non-existing columns correctly", {
  dt <- data.table(TextColumn = c("Hello,123world!"))
  result <- replacePatternsInColumn(dt, "NonExistingColumn", c("[0-9]"), "*")

  expect_equal(dt, result)
})

# Test to ensure other columns remain unchanged
test_that("replacePatternsInColumn does not alter other columns", {
  dt <- data.table(TextColumn = c("Hello,123world!"), UnchangedColumn = c("Unchanged 123 text"))
  patterns_to_replace <- c("[0-9]")
  replacement <- "*"

  result <- replacePatternsInColumn(dt, "TextColumn", patterns_to_replace, replacement)

  expect_equal(result$TextColumn, c("Hello,***world!"))
  expect_equal(result$UnchangedColumn, c("Unchanged 123 text"))
})

###################
# trimTableValues #
###################

# Test trimming functionality for data.frame
test_that("trimTableValues correctly trims all columns in a data.frame", {
  df <- data.frame(
    col1 = c("  A  ", "  B"),
    col2 = c("C  ", " D ")
  )
  expected_df <- data.frame(
    col1 = c("A", "B"),
    col2 = c("C", "D")
  )
  result_df <- trimTableValues(df)
  expect_equal(result_df, expected_df)
})

# Test trimming specified columns in a data.table
test_that("trimTableValues correctly trims specified columns in a data.table", {
  dt <- data.table(
    Column1 = c("  Hello  ", "  World  "),
    Column2 = c("  Test  ", "  Example  ")
  )
  expected_dt <- data.table(
    Column1 = c("Hello", "World"),
    Column2 = c("  Test  ", "  Example  ")
  )
  trimTableValues(dt, colnames = "Column1")
  expect_equal(dt, expected_dt)
})

# Test ignoring non-character columns
test_that("trimTableValues ignores non-character columns", {
  dt <- data.table(
    col1 = c(1, 2),
    col2 = c("  A  ", "  B  ")
  )
  expected_dt <- data.table(
    col1 = c(1, 2),
    col2 = c("A", "B")
  )
  trimTableValues(dt)
  expect_equal(dt, expected_dt)
})

# Test with NA and empty strings
test_that("trimTableValues handles NA and empty strings correctly", {
  dt <- data.table(
    col1 = c("  ", NA, "  C  ")
  )
  expected_dt <- data.table(
    col1 = c("", NA, "C")
  )
  trimTableValues(dt)
  expect_equal(dt, expected_dt)
})

#####################
# splitColumnToRows #
#####################

# Test for basic functionality with "~" as delimiter
test_that("splitColumnToRows splits column into separate rows correctly using ' ~ ' as delimiter", {
  dt <- data.table(
    ID = c(1, 2),
    Text = c("A ~ B", "C ~ D"),
    Other = c(100, 200)
  )
  result <- splitColumnToRows(dt, "Text", split = " ~ ")
  expected <- data.table(
    ID = c(1, 1, 2, 2),
    Text = c("A", "B", "C", "D"),
    Other = c(100, 100, 200, 200)
  )
  expect_equal(result, expected)
})

# Test for handling of columns with no "~" characters
test_that("splitColumnToRows handles columns with no ' ~ ' characters correctly", {
  dt <- data.table(
    ID = c(1, 2),
    Text = c("A", "B"),
    Other = c(100, 200)
  )
  result <- splitColumnToRows(dt, "Text", split = " ~ ")
  expect_equal(result, dt) # Should remain unchanged
})

# Test for preservation of other column values with "~" as delimiter
test_that("splitColumnToRows preserves other column values correctly using ' ~ ' as delimiter", {
  dt <- data.table(
    ID = c(1),
    Text = c("A ~ B"),
    Other = c(100)
  )
  result <- splitColumnToRows(dt, "Text", split = " ~ ")
  expect_equal(result$Other, rep(100, 2))
})

# Test for edge cases with " ~ " as delimiter
test_that("splitColumnToRows handles edge cases correctly using ' ~ ' as delimiter", {
  dt <- data.table(
    ID = c(1, 2, 3, 4),
    Text = c("  ", NA, "A ~ ~ B", "C ~  ~  ~ D"),
    Other = c(100, 200, 300, 400)
  )
  result <- splitColumnToRows(dt, "Text", split = " ~ ")
  expected <- data.table(
    ID = c(1, 2, 3, 3, 4, 4, 4, 4),
    Text = c("  ", NA, "A", "~ B", "C", "", "", "D"),
    Other = c(100, 200, 300, 300, 400, 400, 400, 400)
  )
  # The NA value remains unchanged, and "A ~ ~ B" correctly splits into "A" and "B",
  # considering the delimiter " ~ " and ignoring the empty string between two "~".
  expect_equal(result, expected)
})

#####################
# combineDataTables #
#####################

# Test for basic functionality
test_that("combineDataTables combines data.tables with common columns correctly", {
  dt1 <- data.table(ID = 1:3, Value = c(10, 20, 30))
  dt2 <- data.table(ID = 4:6, Value = c(40, 50, 60))
  dt_list <- list(dt1, dt2)
  result <- combineDataTables(dt_list)
  expected <- data.table(ID = 1:6, Value = c(10, 20, 30, 40, 50, 60))
  expect_equal(result, expected)
})

# Test for handling different columns
test_that("combineDataTables includes only common columns", {
  dt1 <- data.table(ID = 1:3, Value1 = c(10, 20, 30))
  dt2 <- data.table(ID = 4:6, Value2 = c(40, 50, 60))
  dt_list <- list(dt1, dt2)
  result <- combineDataTables(dt_list)
  expected <- data.table(ID = 1:6)
  expect_equal(result, expected)
  expect_false("Value1" %in% names(result))
  expect_false("Value2" %in% names(result))
})

# Test for empty list
test_that("combineDataTables returns NULL for empty list", {
  dt_list <- list()
  result <- combineDataTables(dt_list)
  expect_null(result)
})

# Test for list with one element
test_that("combineDataTables works correctly with a list of one data.table", {
  dt1 <- data.table(ID = 1:3, Value = c(10, 20, 30))
  dt_list <- list(dt1)
  result <- combineDataTables(dt_list)
  expect_equal(result, dt1)
})

# Test for list with NA or empty data.tables
test_that("combineDataTables handles list with NA or empty data.tables correctly", {
  dt1 <- data.table(ID = 1:3, Value = c(10, 20, 30))
  dt_list <- list(dt1, NA, data.table())
  result <- combineDataTables(dt_list)
  expect_equal(result, dt1)
})

###########################
# removeRowsWithNAorEmpty #
###########################

# Test for basic functionality: remove rows where all specified columns are NA or empty
test_that("removeRowsWithNAorEmpty correctly removes rows where all specified columns are NA or empty", {
  my_data <- data.table(
    Column1 = c("A", NA, "World", ""),
    Column2 = c(1, NA, 2, NA),
    Column3 = c("A", " ", "", NA)
  )
  columns_to_check <- c("Column1", "Column3") # Check these columns for NA or empty values
  result_data <- removeRowsWithNAorEmpty(my_data, columns_to_check)
  expected_data <- data.table(
    Column1 = c("A", "World"),
    Column2 = c(1, 2),
    Column3 = c("A", "")
  )
  expect_equal(result_data, expected_data)
})

# Test for no rows removed: when no row has all specified columns as NA or empty
test_that("removeRowsWithNAorEmpty does not remove rows if not all specified columns are NA or empty", {
  my_data <- data.table(
    Column1 = c("Hello", "World", "Again"),
    Column2 = c(1, NA, 3),
    Column3 = c("A", "B", "")
  )
  columns_to_check <- c("Column1", "Column2") # Column3 not considered for removal criteria
  result_data <- removeRowsWithNAorEmpty(my_data, columns_to_check)
  expect_equal(result_data, my_data) # Expect no rows to be removed
})

# Test for strings with whitespaces treated as empty
test_that("removeRowsWithNAorEmpty treats strings of whitespaces as empty", {
  my_data <- data.table(
    Column1 = c("Hello", "   ", NA),
    Column2 = c("World", "Universe", "Galaxy"),
    Column3 = c("A", " ", NA)
  )
  columns_to_check <- c("Column1", "Column3")
  result_data <- removeRowsWithNAorEmpty(my_data, columns_to_check)
  expected_data <- data.table(
    Column1 = c("Hello"),
    Column2 = c("World"),
    Column3 = c("A")
  )
  expect_equal(result_data, expected_data)
})

# Test for mixed data types with NA and empty values across specified columns
test_that("removeRowsWithNAorEmpty handles mixed data types and correctly removes rows with NA and empty values across specified columns", {
  my_data <- data.table(
    Column1 = c("Hello", NA, "World", NA),
    Column2 = c(1, 2, 3, 4),
    Column3 = c("A", NA, "B", " ")
  )
  columns_to_check <- c("Column1", "Column3")
  result_data <- removeRowsWithNAorEmpty(my_data, columns_to_check)
  expected_data <- data.table(
    Column1 = c("Hello", "World"),
    Column2 = c(1, 3),
    Column3 = c("A", "B")
  )
  expect_equal(result_data, expected_data)
})

###########################
# getFirstRowWithPatterns #
###########################

# Test for basic functionality with exact match (grep = FALSE)
test_that("getFirstRowWithPatterns returns correct index with exact match", {
  table <- data.table(
    col1 = c('AAAA', 'A', 'AA', 'AAA'),
    col2 = c('BBBB', 'B', 'BB', 'BBB'),
    col3 = c('CCCC', 'C', 'CC', 'CCC'),
    col4 = c('DDDD', 'D', 'DD', 'DDD')
  )
  index <- getFirstRowWithPatterns(table, c('BBB', 'DDD'), grep = FALSE)
  expect_equal(index, 4)
})

# Test for using grepl for pattern matching (grep = TRUE)
test_that("getFirstRowWithPatterns returns correct index using grepl", {
  table <- data.table(
    col1 = c('AAAA', 'A', 'AA', 'AAA'),
    col2 = c('BBBB', 'B', 'BB', 'BBB'),
    col3 = c('CCCC', 'C', 'CC', 'CCC'),
    col4 = c('DDDD', 'D', 'DD', 'DDD')
  )
  index <- getFirstRowWithPatterns(table, c('BB', 'DD'), grep = TRUE)
  expect_equal(index, 1)
})

# Test when no match is found
test_that("getFirstRowWithPatterns returns -1 when no match is found", {
  table <- data.table(
    col1 = c('AAAA', 'A', 'AA', 'AAA'),
    col2 = c('BBBB', 'B', 'BB', 'BBB'),
    col3 = c('CCCC', 'C', 'CC', 'CCC'),
    col4 = c('DDDD', 'D', 'DD', 'DDD')
  )
  index <- getFirstRowWithPatterns(table, c('ZZZ', 'XXX'), grep = FALSE)
  expect_equal(index, -1)
})

# Test when the number of patterns is greater than the number of columns
test_that("getFirstRowWithPatterns returns -1 when the number of patterns is greater than the number of columns", {
  table <- data.table(
    col1 = c('AAAA', 'A', 'AA', 'AAA'),
    col2 = c('BBBB', 'B', 'BB', 'BBB'),
    col3 = c('CCCC', 'C', 'CC', 'CCC')
  )
  index <- getFirstRowWithPatterns(table, c('A', 'B', 'C', 'D', 'E'), grep = FALSE)
  expect_equal(index, -1)
})

#######################
# removeRowsUpToIndex #
#######################

# Test for removing rows up to a valid index
test_that("removeRowsUpToIndex correctly removes rows up to a specified index", {
  dt <- data.table(ID = 1:6, Name = c("John", "Alice", "Bob", "Eve", "Mike", "Sara"), Age = c(25, 30, 22, 28, 32, 35))
  result_dt <- removeRowsUpToIndex(dt, 3)
  expected_dt <- data.table(ID = 4:6, Name = c("Eve", "Mike", "Sara"), Age = c(28, 32, 35))
  expect_equal(result_dt, expected_dt)
})

# Test for index out of bounds
test_that("removeRowsUpToIndex does nothing if index is out of bounds", {
  dt <- data.table(ID = 1:6, Name = c("John", "Alice", "Bob", "Eve", "Mike", "Sara"), Age = c(25, 30, 22, 28, 32, 35))
  result_dt <- removeRowsUpToIndex(dt, 7) # Index greater than nrow(dt)
  expect_equal(result_dt, dt)
  result_dt <- removeRowsUpToIndex(dt, 0) # Index less than 1
  expect_equal(result_dt, dt)
})

# Test for removing all rows
test_that("removeRowsUpToIndex removes all rows if index equals nrow(dt)", {
  dt <- data.table(ID = 1:6, Name = c("John", "Alice", "Bob", "Eve", "Mike", "Sara"), Age = c(25, 30, 22, 28, 32, 35))
  result_dt <- removeRowsUpToIndex(dt, 6)
  expect_equal(nrow(result_dt), 0)
})

#####################
# removeTableHeader #
#####################

# Test for correct removal of the header and updating column names
test_that("removeTableHeader correctly removes header and updates column names", {
  dt <- data.table(
    X1 = c("Table Info", "", "Name", "John", "Alice", "Bob"),
    X2 = c("", "", "Age", "25", "30", "22"),
    X3 = c("", "", "Country", "USA", "Canada", "UK")
  )
  pattern_list <- c("Name", "Age", "Country")
  result_dt <- removeTableHeader(dt, pattern_list)
  expected_dt <- data.table(
    Name = c("John", "Alice", "Bob"),
    Age = c("25", "30", "22"),
    Country = c("USA", "Canada", "UK")
  )
  expect_equal(result_dt, expected_dt)
})

# Test when header is not found
test_that("removeTableHeader returns NA when header is not found", {
  dt <- data.table(
    X1 = c("John", "Alice", "Bob"),
    X2 = c("25", "30", "22"),
    X3 = c("USA", "Canada", "UK")
  )
  pattern_list <- c("Name", "Age", "Country")
  result <- removeTableHeader(dt, pattern_list)
  expect_equal(result, NA)
})

# Test when header is the first row
test_that("removeTableHeader works correctly when header is the first row", {
  dt <- data.table(
    X1 = c("Name", "John", "Alice", "Bob"),
    X2 = c("Age", "25", "30", "22"),
    X3 = c("Country", "USA", "Canada", "UK")
  )
  pattern_list <- c("Name", "Age", "Country")
  result_dt <- removeTableHeader(dt, pattern_list)
  expected_dt <- data.table(
    Name = c("John", "Alice", "Bob"),
    Age = c("25", "30", "22"),
    Country = c("USA", "Canada", "UK")
  )
  expect_equal(result_dt, expected_dt)
})

#################
# retainColumns #
#################

# Test for retaining specified columns
test_that("retainColumns correctly retains only specified columns", {
  dt <- data.table(
    ID = 1:3,
    Name = c("John", "Alice", "Bob"),
    Age = c(25, 30, 22),
    Country = c("USA", "Canada", "UK")
  )
  columns_to_retain <- c("ID", "Name")
  result_dt <- retainColumns(dt, columns_to_retain)
  expected_dt <- data.table(
    ID = 1:3,
    Name = c("John", "Alice", "Bob")
  )
  expect_equal(result_dt, expected_dt)
})

# Test handling NA in columnNames
test_that("retainColumns does nothing if columnNames is NA", {
  dt <- data.table(
    ID = 1:3,
    Name = c("John", "Alice", "Bob"),
    Age = c(25, 30, 22)
  )
  result_dt <- retainColumns(dt, NA)
  expect_equal(result_dt, dt)
})

# Test column names not in data.table
test_that("retainColumns handles column names not present in the data.table", {
  dt <- data.table(
    ID = 1:3,
    Name = c("John", "Alice", "Bob")
  )
  columns_to_retain <- c("ID", "NonExistingColumn")
  result_dt <- retainColumns(dt, columns_to_retain)
  expected_dt <- data.table(
    ID = 1:3
  )
  expect_equal(result_dt, expected_dt)
})

# Test empty data.table
test_that("retainColumns handles empty data.table correctly", {
  dt <- data.table()
  columns_to_retain <- c("ID", "Name")
  result_dt <- retainColumns(dt, columns_to_retain)
  expect_equal(result_dt, data.table())
})

##############################
# convertListColumnsToString #
##############################

# Test for converting list columns to character columns
test_that("convertListColumnsToString correctly converts list columns to character columns", {
  dt <- data.table(
    ID = 1:3,
    Names = list(c("Alice", "Bob"), c("Charlie", "David"), c("Eve", "Frank")),
    Scores = list(c(85, 92), c(78, 89), c(95, 88))
  )
  result_dt <- convertListColumnsToString(dt)
  expected_dt <- data.table(
    ID = 1:3,
    Names = c("Alice ~ Bob", "Charlie ~ David", "Eve ~ Frank"),
    Scores = c("85 ~ 92", "78 ~ 89", "95 ~ 88")
  )
  expect_equal(result_dt, expected_dt)
})

# Test for handling non-list columns
test_that("convertListColumnsToString does not alter non-list columns", {
  dt <- data.table(
    ID = 1:2,
    Name = c("Alice", "Bob")
  )
  result_dt <- convertListColumnsToString(dt)
  expect_equal(result_dt, dt)
})

# Test for empty lists and lists with NA values
test_that("convertListColumnsToString handles empty lists and lists with NA values correctly", {
  dt <- data.table(
    ID = 1:2,
    Names = list(c(), c(NA, NA)) # will not be changed by convertListColumnsToString(dt)
  )
  result_dt <- convertListColumnsToString(dt)
  expect_equal(result_dt, dt)
})

# Test for custom separator
test_that("convertListColumnsToString works with custom separator", {
  dt <- data.table(
    ID = 1:2,
    Names = list(c("Alice", "Bob"), c("Charlie", "David"))
  )
  result_dt <- convertListColumnsToString(dt, separator = ", ")
  expected_dt <- data.table(
    ID = 1:2,
    Names = c("Alice, Bob", "Charlie, David")
  )
  expect_equal(result_dt, expected_dt)
})

##################
# getcolumnIndex #
##################

# Test for finding an existing column name
test_that("getcolumnIndex returns correct index for an existing column name", {
  dt <- data.table(ID = 1:5, Name = c("Alice", "Bob", "Charlie", "David", "Eve"))
  index <- getcolumnIndex(dt, "Name")
  expect_equal(index, 2)
})

# Test for handling a non-existing column name
test_that("getcolumnIndex returns 0 for a non-existing column name", {
  dt <- data.table(ID = 1:5, Name = c("Alice", "Bob", "Charlie", "David", "Eve"))
  index <- getcolumnIndex(dt, "Age")
  expect_equal(index, 0)
})

# Test for handling NA as column name
test_that("getcolumnIndex returns 0 for NA as column name", {
  dt <- data.table(ID = 1:5, Name = c("Alice", "Bob", "Charlie", "David", "Eve"))
  index <- getcolumnIndex(dt, NA)
  expect_equal(index, 0)
})

####################
# moveColumnBefore #
####################

# Test if moveColumnBefore correctly reorders columns
test_that("moveColumnBefore correctly reorders columns", {
  dt <- data.table(a = 1:3, b = 4:6, c = 7:9)
  moveColumnBefore(dt, "b", "c")
  expect_equal(names(dt), c("a", "c", "b"))

  dt <- data.table(a = 1:3, b = 4:6, c = 7:9)
  moveColumnBefore(dt, "a", "c")
  expect_equal(names(dt), c("b", "c", "a"))
})

# Test if moveColumnBefore does not change the data
test_that("moveColumnBefore does not change the data", {
  dt <- data.table(a = 1:3, b = 4:6, c = 7:9)
  original_dt <- data.table::copy(dt)
  moveColumnBefore(dt, "b", "c")
  expect_equal(dt$a, original_dt$a)
  expect_equal(dt$b, original_dt$b)
  expect_equal(dt$c, original_dt$c)
})

# Test if moveColumnBefore handles non-existing columns
test_that("moveColumnBefore handles non-existing columns", {
  dt <- data.table(a = 1:3, b = 4:6, c = 7:9)
  expect_error(moveColumnBefore(dt, "x", "c"))
  expect_error(moveColumnBefore(dt, "a", "y"))
})

# Test if moveColumnBefore with already correct order does nothing
test_that("moveColumnBefore with already correct order does nothing", {
  dt <- data.table(a = 1:3, b = 4:6, c = 7:9)
  original_order <- names(dt)
  moveColumnBefore(dt, "b", "c")
  expect_equal(names(dt), original_order)
})

#######################
# collapseRowsByGroup #
#######################

# Test for collapsing rows by group with more than one row
test_that("collapseRowsByGroup collapses rows by group and handles NAs correctly", {
  dt <- data.table(
    id = c(1, 2, 3, 3),
    group = c("A", "A", "B", "B"),
    name = c("Alice", "Bob", "Charlie", "Alice"),
    pat_identifier_system = c("[1.1]abcdefg", "[1.2.3]hijklmn", "[2.3.4.5]opqrstu", NA),
    status = c(NA, NA, "ok", "error")
  )
  result <- collapseRowsByGroup(dt, "group")
  expect_equal(nrow(result), 2)
  expect_equal(result$group, c("A", "B"))
  expect_equal(result$id, c("1; 2", "3"))
  expect_equal(result$name, c("Alice; Bob", "Charlie; Alice"))
  expect_equal(result$pat_identifier_system, c("[1.1]abcdefg; [1.2.3]hijklmn", "[2.3.4.5]opqrstu"))
  expect_equal(result$status, c(NA_character_, "ok; error"))
})

# Test for collapsing all rows without grouping
test_that("collapseRowsByGroup collapses all rows without grouping and handles NAs correctly", {
  dt <- data.table(
    id = c(1, 2, 3, 3),
    group = c("A", "A", "B", "B"),
    name = c("Alice", "Bob", "Charlie", "Alice"),
    pat_identifier_system = c("[1.1]abcdefg", "[1.2.3]hijklmn", "[2.3.4.5]opqrstu", NA),
    status = c(NA, NA, "ok", "error")
  )
  result <- collapseRowsByGroup(dt)
  expect_equal(nrow(result), 1)
  expect_equal(result$id, "1; 2; 3")
  expect_equal(result$name, "Alice; Bob; Charlie")
  expect_equal(result$pat_identifier_system, "[1.1]abcdefg; [1.2.3]hijklmn; [2.3.4.5]opqrstu")
  expect_equal(result$status, "ok; error")
})

# Test for handling a single row table
test_that("collapseRowsByGroup returns the table unchanged if it has only one row", {
  dt <- data.table(
    id = 1,
    group = "A",
    name = "Alice",
    pat_identifier_system = "[1.1]abcdefg",
    status = "ok"
  )
  result <- collapseRowsByGroup(dt)
  expect_equal(result, dt)
})

# Test for handling an empty table
test_that("collapseRowsByGroup handles an empty table", {
  dt <- data.table(id = integer(), group = character(), name = character(), pat_identifier_system = character(), status = character())
  result <- collapseRowsByGroup(dt)
  expect_equal(nrow(result), 0)
  expect_equal(ncol(result), 5)
})

# Test for handling columns with all NAs
test_that("collapseRowsByGroup handles columns with all NAs correctly", {
  dt <- data.table(
    id = c(NA, NA, NA),
    group = c(NA, NA, NA),
    name = c(NA, NA, NA),
    pat_identifier_system = c(NA, NA, NA),
    status = c(NA, NA, NA)
  )
  result <- collapseRowsByGroup(dt)
  expect_equal(nrow(result), 1)
  expect_true(all(is.na(result$id)))
  expect_true(all(is.na(result$name)))
  expect_true(all(is.na(result$pat_identifier_system)))
  expect_true(all(is.na(result$status)))
})

#####################
# printTableSummary #
#####################

test_that("printTableSummary prints a summary for a table", {
  # Capture the output of printTableSummary
  temp_output <- capture.output(printTableSummary(table = mtcars, table_name = 'mtcars'))

  # Check if the table name is present in the output
  expect_match(temp_output[2], "Table: mtcars")

  # Check the number of rows and columns output
  expect_match(temp_output[4], "# Rows:    32")
  expect_match(temp_output[5], "# Columns: 11")

  # Check if column information headers are present
  expect_match(temp_output[7], "  Column    Class    Type  Available  Missing  ")
})

########################
# dataTableAsCharacter #
########################

test_that("dataTableAsCharacter converts a simple data.table without header and footer", {
  dt <- data.table(a = 1:3, b = c("x", "y", "z"))
  expected_output <- "1  x\n2  y\n3  z"
  expect_equal(dataTableAsCharacter(dt), expected_output)
})

test_that("dataTableAsCharacter includes header when specified", {
  dt <- data.table(a = 1:3, b = c("x", "y", "z"))
  expected_output <- "a  b\n1  x\n2  y\n3  z"
  expect_equal(dataTableAsCharacter(dt, header = TRUE), expected_output)
})

test_that("dataTableAsCharacter includes footer when specified", {
  dt <- data.table(a = 1:3, b = c("x", "y", "z"))
  expected_output <- "1  x\n2  y\n3  z\na  b"
  expect_equal(dataTableAsCharacter(dt, footer = TRUE), expected_output)
})

test_that("dataTableAsCharacter includes both header and footer when specified", {
  dt <- data.table(a = 1:3, b = c("x", "y", "z"))
  expected_output <- "a  b\n1  x\n2  y\n3  z\na  b"
  expect_equal(dataTableAsCharacter(dt, header = TRUE, footer = TRUE), expected_output)
})

test_that("dataTableAsCharacter handles different column widths", {
  dt <- data.table(a = 1:3, b = c("longer", "y", "z"))
  expected_output <- "1  longer\n2       y\n3       z"
  expect_equal(dataTableAsCharacter(dt), expected_output)
})

test_that("dataTableAsCharacter handles empty data.table", {
  dt <- data.table(a = integer(0), b = character(0))
  expected_output <- ""
  expect_equal(dataTableAsCharacter(dt), expected_output)
})

test_that("dataTableAsCharacter handles single row data.table", {
  dt <- data.table(a = 1, b = "x")
  expected_output <- "1  x"
  expect_equal(dataTableAsCharacter(dt), expected_output)
})

test_that("dataTableAsCharacter handles single column data.table", {
  dt <- data.table(a = 1:3)
  expected_output <- "1\n2\n3"
  expect_equal(dataTableAsCharacter(dt), expected_output)
})

test_that("dataTableAsCharacter handles single column data.table with header and footer", {
  dt <- data.table(a = 1:3)
  expected_output <- "a\n1\n2\n3\na"
  expect_equal(dataTableAsCharacter(dt, header = TRUE, footer = TRUE), expected_output)
})

#####################
# fhirCompleteTable #
#####################

# define class TableDescription
setClass(
  "TableDescription",
  slots = list(
    cols = "list"
  )
)
# example table description
table_description <- new("TableDescription", cols = list(a = "character", b = "character", c = "character"))

test_that("fhirCompleteTable adds missing columns to the table", {
  dt <- data.table(a = 1:3, b = c("x", "y", "z"))
  expected_output <- data.table(a = as.character(1:3), b = c("x", "y", "z"), c = NA_character_)
  result <- fhirCompleteTable(dt, table_description)
  expect_equal(result, expected_output)
})

test_that("fhirCompleteTable handles empty input table", {
  dt <- data.table()
  expected_output <- data.table(a = character(0), b = character(0), c = character(0))
  result <- fhirCompleteTable(dt, table_description)
  expect_equal(result, expected_output)
})

test_that("fhirCompleteTable handles table with all columns present", {
  dt <- data.table(a = 1:3, b = c("x", "y", "z"), c = c("p", "q", "r"))
  expected_output <- data.table(a = as.character(1:3), b = c("x", "y", "z"), c = c("p", "q", "r"))
  result <- fhirCompleteTable(dt, table_description)
  expect_equal(result, expected_output)
})

test_that("fhirCompleteTable converts column types to character", {
  dt <- data.table(a = 1:3, b = c("x", "y", "z"), c = c(TRUE, FALSE, TRUE))
  expected_output <- data.table(a = as.character(1:3), b = c("x", "y", "z"), c = as.character(c(TRUE, FALSE, TRUE)))
  result <- fhirCompleteTable(dt, table_description)
  expect_equal(result, expected_output)
})

test_that("fhirCompleteTable handles input table with additional columns", {
  dt <- data.table(a = 1:3, b = c("x", "y", "z"), d = c("extra1", "extra2", "extra3"))
  expected_output <- data.table(a = as.character(1:3), b = c("x", "y", "z"), c = NA_character_)
  result <- fhirCompleteTable(dt, table_description)
  expect_equal(result[, .(a, b, c)], expected_output)
})

##########################
# fillNAWithLastRowValue #
##########################

test_that("fillNAWithLastRowValue fills NA values in all columns by default", {
  dt <- data.table(A = c(1, NA, NA, 4, 5), B = c("x", NA, "z", NA, NA))
  result <- fillNAWithLastRowValue(dt)
  expected <- data.table(A = c(1, 1, 1, 4, 5), B = c("x", "x", "z", "z", "z"))
  expect_equal(result, expected)
})

test_that("fillNAWithLastRowValue fills NA values in specified columns", {
  dt <- data.table(A = c(1, NA, NA, 4, 5), B = c("x", NA, "z", NA, NA))
  result <- fillNAWithLastRowValue(dt, columns = "A")
  expected <- data.table(A = c(1, 1, 1, 4, 5), B = c("x", NA, "z", NA, NA))
  expect_equal(result, expected)
})

test_that("fillNAWithLastRowValue handles cases where the first value is NA", {
  dt <- data.table(A = c(NA, 2, NA, 4, 5), B = c(NA, NA, "y", NA, "z"))
  result <- fillNAWithLastRowValue(dt)
  expected <- data.table(A = c(NA, 2, 2, 4, 5), B = c(NA, NA, "y", "y", "z"))
  expect_equal(result, expected)
})

test_that("fillNAWithLastRowValue handles data.table with no NA values", {
  dt <- data.table(A = c(1, 2, 3, 4, 5), B = c("a", "b", "c", "d", "e"))
  result <- fillNAWithLastRowValue(dt)
  expect_equal(result, dt)
})

test_that("fillNAWithLastRowValue handles columns with only NA values", {
  dt <- data.table(A = c(NA, NA, NA), B = c(1, 2, 3))
  result <- fillNAWithLastRowValue(dt, columns = "A")
  expected <- data.table(A = c(NA, NA, NA), B = c(1, 2, 3))
  expect_equal(result, expected)
})

test_that("fillNAWithLastRowValue handles single column data.table", {
  dt <- data.table(A = c(1, NA, 3, NA, 5))
  result <- fillNAWithLastRowValue(dt)
  expected <- data.table(A = c(1, 1, 3, 3, 5))
  expect_equal(result, expected)
})

####################
# splitTableToList #
####################

test_that("splitTableToList splits the data.table correctly by specified column", {
  dt <- data.table(SCRIPTNAME = c("A", "A", "B", "B", "C"), VALUE = 1:5)
  result <- splitTableToList(dt, "SCRIPTNAME")

  expect_equal(length(result), 3)
  expect_equal(names(result), c("A", "B", "C"))

  expect_equal(result$A, data.table(SCRIPTNAME = c("A", "A"), VALUE = 1:2))
  expect_equal(result$B, data.table(SCRIPTNAME = c("B", "B"), VALUE = 3:4))
  expect_equal(result$C, data.table(SCRIPTNAME = "C", VALUE = 5))
})

test_that("splitTableToList handles NA values in the split column correctly", {
  dt <- data.table(SCRIPTNAME = c("A", NA, "B", NA, "C"), VALUE = 1:5)
  result <- splitTableToList(dt, "SCRIPTNAME")

  expect_equal(length(result), 3)
  expect_equal(names(result), c("A", "B", "C"))

  expect_equal(result$A, data.table(SCRIPTNAME = c("A", "A"), VALUE = 1:2))
  expect_equal(result$B, data.table(SCRIPTNAME = c("B", "B"), VALUE = 3:4))
  expect_equal(result$C, data.table(SCRIPTNAME = "C", VALUE = 5))
})

# Test: Fill NA values in all columns
test_that("fillNAWithLastRowValue fills NA values in all columns", {
  dt <- data.table::data.table(A = c(1, NA, NA, 4, 5), B = c("x", NA, "z", NA, NA))
  result <- fillNAWithLastRowValue(dt)
  expected <- data.table::data.table(A = c(1, 1, 1, 4, 5), B = c("x", "x", "z", "z", "z"))
  expect_equal(result, expected)
})

# Test: Fill NA values in specific columns
test_that("fillNAWithLastRowValue fills NA values in specified columns", {
  dt <- data.table::data.table(A = c(1, NA, NA, 4, 5), B = c("x", NA, "z", NA, NA))
  result <- fillNAWithLastRowValue(dt, columns = "B")
  expected <- data.table::data.table(A = c(1, NA, NA, 4, 5), B = c("x", "x", "z", "z", "z"))
  expect_equal(result, expected)
})

# Test: No NA values to fill
test_that("fillNAWithLastRowValue handles no NA values case", {
  dt <- data.table::data.table(A = c(1, 2, 3, 4, 5), B = c("x", "y", "z", "w", "v"))
  result <- fillNAWithLastRowValue(dt)
  expected <- data.table::data.table(A = c(1, 2, 3, 4, 5), B = c("x", "y", "z", "w", "v"))
  expect_equal(result, expected)
})

# Test: Single-row data.table
test_that("fillNAWithLastRowValue handles single-row data.table", {
  dt <- data.table::data.table(A = c(1), B = c("x"))
  result <- fillNAWithLastRowValue(dt)
  expected <- data.table::data.table(A = c(1), B = c("x"))
  expect_equal(result, expected)
})

# Test: Single-row data.table with all values NA
test_that("fillNAWithLastRowValue handles single-row data.table with all values NA", {
  dt <- data.table::data.table(A = NA, B = NA)
  result <- fillNAWithLastRowValue(dt)
  expected <- data.table::data.table(A = NA, B = NA)
  expect_equal(result, expected)
})

# Test: First value in column is NA
test_that("fillNAWithLastRowValue handles first value in column being NA", {
  dt <- data.table::data.table(A = c(NA, 1, 2, NA, 5), B = c(NA, "x", "y", "z", NA))
  result <- fillNAWithLastRowValue(dt)
  expected <- data.table::data.table(A = c(NA, 1, 2, 2, 5), B = c(NA, "x", "y", "z", "z"))
  expect_equal(result, expected)
})

# Test: Columns parameter is NA (default) -> all columns are processed
test_that("fillNAWithLastRowValue processes all columns if columns parameter is NA", {
  dt <- data.table::data.table(A = c(1, NA, 3), B = c("a", NA, "c"))
  result <- fillNAWithLastRowValue(dt)
  expected <- data.table::data.table(A = c(1, 1, 3), B = c("a", "a", "c"))
  expect_equal(result, expected)
})

#######################
# replaceColumnValues #
#######################

# Test replacing non-NA values
test_that("Non-NA values are replaced correctly", {
  dt <- data.table::data.table(a = c("x", "y", "x", "y"))
  replaceColumnValues(dt, "a", "x", "z")
  expect_equal(dt$a, c("z", "y", "z", "y"))
})

# Test replacing NA values
test_that("NA values are replaced correctly", {
  dt <- data.table::data.table(a = c("x", NA, "x", "y"))
  replaceColumnValues(dt, "a", NA, "unknown")
  expect_equal(dt$a, c("x", "unknown", "x", "y"))
})

# Test replacing with NA values
test_that("Values are replaced with NA correctly", {
  dt <- data.table::data.table(a = c("x", "y", "x", "y"))
  replaceColumnValues(dt, "a", "x", NA)
  expect_equal(dt$a, c(NA, "y", NA, "y"))
})

# Test with no matching values
test_that("No changes when no matching values are found", {
  dt <- data.table::data.table(a = c("x", "y", "x", "y"))
  replaceColumnValues(dt, "a", "z", "w")
  expect_equal(dt$a, c("x", "y", "x", "y"))
})

# Test with column containing only NA values
test_that("Column with only NA values is handled correctly", {
  dt <- data.table::data.table(a = c(NA_character_, NA_character_, NA_character_))
  replaceColumnValues(dt, "a", NA, "unknown")
  expect_equal(dt$a, c("unknown", "unknown", "unknown"))
})

# Test with all values replaced
test_that("All values in the column are replaced correctly", {
  dt <- data.table::data.table(a = c("x", "x", "x"))
  replaceColumnValues(dt, "a", "x", "z")
  expect_equal(dt$a, c("z", "z", "z"))
})

####################
# mergeTablesUnion #
####################

# Test 1: Table exists only in list1
test_that("mergeTablesUnion correctly handles tables present only in list1", {
  list1 <- list(tableA = data.table(x = 1:3, y = 4:6))
  list2 <- list(tableB = data.table(x = 7:9, z = 10:12))

  # Perform the merge
  merged_tables <- mergeTablesUnion(list1, list2)

  # Check if tableA from list1 is retained without modification
  expect_equal(nrow(merged_tables$tableA), 3)
  expect_equal(colnames(merged_tables$tableA), c("x", "y"))

  # Check if tableB from list2 is retained without modification
  expect_equal(nrow(merged_tables$tableB), 3)
  expect_equal(colnames(merged_tables$tableB), c("x", "z"))
})

# Test 2: Table exists only in list2
test_that("mergeTablesUnion correctly handles tables present only in list2", {
  list1 <- list(tableA = data.table(x = 1:3, y = 4:6))
  list2 <- list(tableB = data.table(x = 7:9, z = 10:12))

  # Perform the merge
  merged_tables <- mergeTablesUnion(list1, list2)

  # Check if tableA from list1 is retained without modification
  expect_equal(nrow(merged_tables$tableA), 3)
  expect_equal(colnames(merged_tables$tableA), c("x", "y"))

  # Check if tableB from list2 is retained without modification
  expect_equal(nrow(merged_tables$tableB), 3)
  expect_equal(colnames(merged_tables$tableB), c("x", "z"))
})

# Test 3: Empty lists
test_that("mergeTablesUnion correctly handles empty lists", {
  list1 <- list()
  list2 <- list()

  # Perform the merge
  merged_tables <- mergeTablesUnion(list1, list2)

  # Check that the result is an empty list
  expect_equal(length(merged_tables), 0)
})

# Test 4: Different column order
test_that("mergeTablesUnion correctly merges tables with different column orders", {
  list1 <- list(tableA = data.table(x = 1:3, y = 4:6))
  list2 <- list(tableA = data.table(y = 7:9, x = 10:12))

  # Perform the merge
  merged_tables <- mergeTablesUnion(list1, list2)

  # Ensure the columns are merged correctly, regardless of order
  expect_equal(colnames(merged_tables$tableA), c("x", "y"))
  expect_equal(nrow(merged_tables$tableA), 6)  # Should have 6 rows
})

# Test 5: Tables with more rows in both lists
test_that("mergeTablesUnion correctly merges tables with different numbers of rows", {
  list1 <- list(tableA = data.table(x = 1:3, y = 4:6))
  list2 <- list(tableA = data.table(x = 4:6, y = 7:9))

  # Perform the merge
  merged_tables <- mergeTablesUnion(list1, list2)

  # Check the number of rows (should be 6)
  expect_equal(nrow(merged_tables$tableA), 6)
  expect_equal(colnames(merged_tables$tableA), c("x", "y"))  # Only common columns
})
